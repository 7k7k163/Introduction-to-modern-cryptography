% !TEX root = ../../现代密码学简介.tex
\chapter{对称密码}
\section{什么是对称密码}
通过上一章我们知道，一个密码体制由明文空间、密文空间、密钥空间、加密算法、解密算法构成。如果两个人要进行加密通信，那么发送者利用密钥，使用加密算法加密明文，生成密文，将密文传递给接收者。接收者利用密钥，使用解密算法解密密文，生成明文。这就是加密通信的基本过程。那么所谓的对称密码，就是在一次加密通信的过程中，发送者和接收者使用的密钥是同一个密钥。
\section{对称密码要研究什么}
从我们上面叙述的过程来看，对称密码主要需要研究两个部分：用什么方式加密、解密，以及如何让加密和解密者共享同一个密钥。\par
所谓用什么方式加密、解密，主流方法为使用流密码或分组密码。而密钥共享的方式，则有许多种。本章主要的内容就是阐述这两个方面。
\section{对称密码的加密、解密方式}
从上一章我们可以知道，最安全的密码，是一次一密。即：\par
对于$n$位二进制串明文$m_1m_2\cdots m_n$, 密钥为$n$位二进制串$k_1k_2\cdots k_n$，其每一位都是$0$或$1$的随机数。密文为$n$位二进制串$c_1c_2\cdots c_n$, 加密方式为明文与密钥的逐比特异或，解密方式为密文与密钥的逐比特异或。\par
同时我们知道，一次一密虽然是完全安全的，但其缺陷也很明显。首先，既然密钥的长度和明文一样长，并且在加密通信前双方都要知道密钥，那不如双方直接共享明文；其次，同一个随机生成的密钥只能使用于一次加密通信，否则安全性就会降低。\par
为了解决这一问题，在对称密码体制中采用了两种方法：流密码与分组密码。\par
所谓流密码，就是采用一个较短的密钥，以这个较短的密钥生成一个和明文一样长的，近似随机的密钥流，然后再像一次一密那样加密。因此，如果密钥流的随机性接近于一次一密中密钥的真随机性，那么其安全性就会极高。但是，流密码中的密钥流不可能是真随机的，因为加解密双方共享的是那个较短的密钥，而为了加解密的成功性，由这个较短的密钥生成的密钥流也应是相同的，因此，这个密钥流实际上是确定的。所以，流密码的安全性，就在于以较短的密钥生成密钥流的算法。\par
所谓分组密码，就是将明文分成若干个相同长度的分组，然后对每个分组进行加密。从本质上来说，分组密码实际上处理的是固定长度明文的问题。大多数的分组密码，都是采用扩散、混淆等传统对称密码中采用的加密手段，让明文与密文、密文与密钥之间的关系尽可能地难以破解。
\section{对称密码的密钥分配方式}
\subsubsection{安全协议记号}
接下来，我们将叙述具体的安全协议。为了方便叙述，我们使用了通用的安全协议记号，即：
\[A\to B: M\]
代表$A$发送给$B$一个消息$M$.
\[A\to B: \brace{X}_{K_{A, B}}\]
代表$A$发送给$B$一个信息，该信息是用密钥$K_{A, B}$加密明文$X$获得的密文。
\subsubsection{介绍}
对称密码的密钥分配问题，我们主要研究的是在一个节点充分多的网络中如何建立高效、安全的信道。这个问题是有其实际意义的。试想在一个互联网公司内，有许多员工和服务器。对每个服务器，每个员工都需要利用自己的账号密码登陆。那么，如果有$m$个员工和$n$个服务器，那么最原始的想法，每个员工、服务器之间都拥有一个密钥，那么总共需要$mn$个密钥。那么这能不能够优化呢？我们下面抽象该问题：
\subsubsection{点对点密钥分配}
我们现在考虑有$n$个人，他们需要进行对称密码的加密通信。那么，由于每次对称密码通信都需要一个密钥，所以，最原始的想法是这$n$个人两两之间有一个密钥用于长期的加密通信。那么，这$n$个人两两加密通信就一共需要$\ext\frac{n\pth{n-1}}{2}$个密钥。这种做法常被称作点对点密钥分配。其好处是安全，如果在这个加密通信网络中有一个人泄露了密钥，那么只有与这个人进行的加密通信受到影响，其他人之间的加密通信是不会受到影响的。但是，其缺点为可延展性差。密钥的数量是$O(n^2)$量级的，这导致密钥的数量会随着加密通信网络成员的增多而迅速增多。同时，新成员的加入、旧成员的减少都会影响这整个加密通信网络的成员。\par
在实际应用中，确实也会用点对点密钥分配的方法。但这仅仅是用于一个网络中的一小部分。在这个群体中，每两个人之间都拥有一个主密钥$K_{AB}$, 他们每次安全通信用的密钥，称为会话密钥$K_{ab}$. 其生成方法为：
\begin{enumerate}
	\item $A$向$B$发送如下消息：
	\[A\to B: \ID_A, \ID_B, N_1\]
	其中$\ID_A, \ID_B$为$A$与$B$的身份识别号, $N_1$是$A$生成的一个一次性随机数
	\item $B$向$A$发送如下消息：
	\[B\to A: \brace{K_{ab}, \ID_A, \ID_B, f(N_1), N_2}_{K_{AB}}\]
	其中$K_{ab}$是$B$生成的会话密钥，$K_{AB}$是$A, B$共有的主密钥, $f(N_1)$是一个简单的函数，比如说$f(N_1)=N_1-1$, 目的是让$A$知道$B$确实收到了$N_1$.
	\item $A$通过$K_{AB}$解密收到的消息，并向$B$发送如下消息：
	\[A\to B:\brace{f(N_2)}_{K_{ab}}\]
	以让$B$知道$A$确实收到了$N_2$.
\end{enumerate}
\subsubsection{密钥分配中心}
为了弥补点对点密钥分配的缺点，我们想到的最有效的方法是将这些缺点从加密通信的双方身上转移到一个第三方机构——密钥分配中心(Key Distribution Center, KDC). 其具体做法为：\par
每一个加密通信网络中的用户，都与KDC共享一个密钥，称为主密钥。因此，$n$个节点的加密通信网络中共有$n$个主密钥。在一次加密通信的过程中，加密通信双方利用主密钥，向KDC请求一个密钥，称为会话密钥。双方利用会话密钥进行加密通信。加密通信完成后，会话密钥即可销毁。\par
从上述过程中我们可以看到，加密通信网络的密钥数量从$O(n^2)$变为了$O(n)$, 同时新成员的加入、旧成员的减少都不会影响整个加密通信网络中的任何一个成员。
\subsubsection{NS协议}
基于KDC的密钥分配方式，其核心在于如何利用主密钥获得会话密钥。常用的方法为Needham-Schroeder协议，简称NS协议。其基本步骤为：\par
假设A和B要进行加密通信，$S$为KDC, $K_{AS}, K_{BS}$分别是$A$和$B$拥有的主密钥，$\ID_A, \ID_B$分别为$A$和$B$的身份识别号，$N_A, N_B$分别为$A$和$B$产生的一个一次性随机数，$K_{AB}$为加密通信所需要的会话密钥。那么，其步骤为：
\begin{enumerate}
	\item $A$发送给$S$一个信息，用于确定他和$B$的身份，告诉$S$他想与$B$进行通信
	\[A\to S: \ID_A, \ID_B, N_A\]
	\item KDC, 即$S$, 生成一个$K_{AB}$, 并将其用$K_{BS}$与一部分数据加密后返回给$A$
	\[S\to A: \brace{N_A, K_{AB}, \ID_B, \brace{K_{AB}, \ID_A}_{K_{BS}}}_{K_{AS}}\]
	\item $A$使用$K_{AS}$解密了上一步获得的密文，同时将得到的$\brace{K_{AB}, A}_{K_{BS}}$发送给$B$
	\[A\to B: \brace{K_{AB}, \ID_A}_{K_{BS}}\]
	\item $B$发送给$A$一个用$K_{AB}$加密的随机数
	\[B\to A: \brace{N_B}_{K_{AB}}\]
	\item $A$利用$K_{AB}$解密了上一步得到的密文，并将其减一后用$K_{AB}$加密发送给$B$
	\[A\to B: \brace{N_B - 1}_{K_{AB}}\]
\end{enumerate}

我们在分析安全通信协议的时候，需要考虑的是，如何证明本轮收到的信息是对方发的，并且是针对自己上一轮发送信息的回馈。那么，我们从第二轮开始分析：\par
第二轮中，由于$K_{AS}$只有$A$和$S$知道，因此，如果能用$K_{AS}$正确解密信息，就说明获得的信息是$S$发的。同时，如果解密得到了$N_A$，就说明这次收到的信息是$S$针对上次发送的信息的回馈。\par
第五轮中，由于$K_{BS}$只有$B$和$S$知道，因此，只有$B$能获得第三轮中发送的$K_{AB}$. 因此，如果$B$使用$K_{AB}$解密得到的信息确实是第四步生成的随机数减一，那么就说明获得的信息确实是$A$发的，并且也确实是对之前发送信息的回馈。\par
但是，这样的安全通信协议可以被重放攻击。如果一个攻击者使用了一个旧的，已经被泄露出来的$K_{AB}$, 那么他可以重放信息$\brace{K_{AB}, A}_{K_{BS}}$给$B$, 从而让$B$误以为自己是$A$. 这样攻击的主要原因就在于该协议的第三步中，$B$无法确定发送者是否是当前的$A$.\par
在实际应用中，比如说，一个员工可以多次重复上述协议的前几步，收集其与每台服务器之间通信的$\brace{K_{AB}, \ID_A}_{K_{BS}}$. 那么即使他被解雇了，他依然可以利用这些信息来登录服务器。这个漏洞在被指出之前，持续了有快十年。
\subsubsection{Kerberos}
Kerberos是现在使用最广泛的一种基于对称密钥的安全通信协议。Kerberos是希腊神话中冥王哈迪斯的地狱三头犬，是MIT最初为了保护雅典娜工程提供的网络服务器而发明的。其起名为地狱三头犬也表明了这种协议十分安全。该协议现在广泛的应用于Windows, macOS等处。
\subsubsection{完整过程}
Kerberos安全通信的完整过程，是由客户向KDC发出安全通信请求，然后获得会话密钥后与特定服务器通信的过程。也就是说，先前我们提到的两个人之间的通信，在这里可以理解成一个用户$C$和一个服务器$S$之间的通信。同时，KDC中也有两个服务器：认证服务器AS和票据授权服务器TGS. 而之前提到的主密钥，在这里，则是用户$C$与TGS之间通信的密钥。\par
Kerberos的完整过程包括几个部分：
\begin{itemize}
	\item 客户认证\par
	该部分的作用主要在于使用户$C$拥有与TGS之间通信的主密钥$K_{C, \mathrm{TGS}}$, 在Kerberos中与之相关的一个概念是票据授权票据TGT. 其步骤为：
	\begin{enumerate}
		\item 用户向认证服务器发送如下信息：
		\[C\to\mathrm{AS}: \ID_C, \ID_{\mathrm{TGS}}, \mathrm{IPs}, \mathrm{Lifetime}\]
		其中$\ID_C, \ID_{\mathrm{TGS}}$分别是$C$与TGS的身份识别号，$\mathrm{IPs}$是$C$的IP地址范围。而Lifetime则是其申请的TGT能持续的时间。
		\item 认证服务器向用户发送如下信息：
		\[\mathrm{AS}\to C: \brace{\ID_{\mathrm{TGS}}, T_1, \mathrm{Lifetime}, K_{C, \mathrm{TGS}}}_{K_{\mathrm{User}}}, \brace{\ID_C, \ID_{\mathrm{TGS}}, \mathrm{IPs}, T_1, \mathrm{Lifetime}, K_{C, \mathrm{TGS}}}_{K_{\mathrm{TGS}}}\]
		其中$T_1$为时间戳，$K_{\mathrm{User}}$是AS与$C$共有的一个密钥，$K_{TGS}$是AS与TGS共有的一个密钥。\par
		同时，$\ID_C, \ID_{\mathrm{TGS}}, \mathrm{IPs}, T_1, \mathrm{Lifetime}, K_{C, \mathrm{TGS}}$被称作票据授权票据TGT.
		\item $C$可以利用自己拥有的$K_{\mathrm{User}}$解密获得消息的第一部分，从而获得与TGS之间通信的主密钥$K_{C, \mathrm{TGS}}$.
	\end{enumerate}
	\item 服务授权\par
	该部分的作用主要是使用户和TGS之间进行通信从而获得与目的服务器$S$之间通信的会话密钥$K_{C, S}$。其步骤为：
	\begin{enumerate}
		\item 用户向票据授权服务器发送如下信息：
		\[C\to\mathrm{TGS}: \ID_{S}, \mathrm{Lifetime}, \brace{\ID_C, T_2}_{K_{C, \mathrm{TGS}}}, \brace{\mathrm{TGT}}_{K_{\mathrm{TGS}}}\]
		其中$\brace{\mathrm{TGT}}_{K_{\mathrm{TGS}}}$是用户从AS获得信息的第二部分。
		\item 票据授权服务器用$K_{\mathrm{TGT}}$解密最后一个部分，得到TGT, 从而获得$K_{C, \mathrm{TGS}}$, 然后解密倒数第二个部分。接着检查：
		\begin{itemize}
			\item TGT没有过期。\par
			即票据授权服务器获得信息的时间与TGT中时间戳$T_1$之间的时间差要在Lifetime允许的范围内。
			\item 倒数第二个部分中的$\ID_{C}$与TGT中的$\ID_C$是一致的
			\item 倒数第二个部分也没有过期。\par
			即票据授权服务器获得信息的时间与倒数第二个部分中的时间戳$T_2$之间的时间差要在Lifetime允许的范围内。
			\item 如果IPs非空那么检查该信息的发送源IP是否在这之中。
		\end{itemize}
		\item 票据授权服务器向用户发送如下信息：
		\[\mathrm{TGS}\to C: \brace{\ID_S, T_3, \mathrm{Lifetime}, K_{C, S}}_{K_{C, \mathrm{TGS}}}, \brace{\ID_C, \ID_S, \mathrm{IPs}, \mathrm{Lifetime}, K_{C, S}}_{K_{\mathrm{Server}}}\]
		其中$K_{C, S}$即为$C$与$S$通信的会话密钥，$K_{\mathrm{Server}}$是TGS与$S$共有的一个密钥。\par
		同时，$\ID_C, \ID_S, \mathrm{IPs}, \mathrm{Lifetime}, K_{C, S}$被称作票据Ticket.
		\item $C$可以利用自己拥有的$K_{C, \mathrm{TGS}}$解密第一部分，从而获得$K_{C, S}$
	\end{enumerate}
	\item 服务请求\par
	该部分是用户与目的服务器之间建立安全信道通信。其步骤为：
	\begin{enumerate}
		\item 用户向目的服务器发送如下信息：
		\[C\to S: \brace{\ID_C, T_4}_{K_{C, S}}, \brace{\mathrm{Ticket}}_{K_{\mathrm{Server}}}\]
		其中后半部分是$C$之前收到的信息
		\item $S$用自己拥有的$K_{\mathrm{Server}}$密钥解密第二部分，获得$K_{C, S}$解密第一部分，然后检查：
		\begin{itemize}
			\item Ticket没有过期。\par
			即服务器获得信息的时间与时间戳$T_2$之间的时间差要在Lifetime允许的范围内。
			\item 第一部分中的$\ID_C$与第二部分中的$\ID_C$是一致的
			\item 第一部分也没有过期。\par
			即服务器获得信息的时间与时间戳$T_4$之间的时间差在Lifetime允许的范围内。
			\item 如果IPs非空那么检查该信息的发送源IP是否在这之中。
		\end{itemize}
	\end{enumerate}	
\end{itemize}

由于Kerberos涉及了许多密钥，下面这张表格给出了每一个参与者获得相应密钥的步骤
\begin{table}[H]
\centering
\begin{tabular}{c|c|c|c|c|c}\hline
&$K_{\mathrm{User}}$&$K_{\mathrm{TGS}}$&$K_{\mathrm{Server}}$&$K_{C, \mathrm{TGS}}$&$K_{C, S}$\\\hline
C&预先获得&&&客户认证3&服务授权4\\\hline
AS&预先获得&预先获得&&由其生成&\\\hline
TGS&&预先获得&预先获得&服务授权2&由其生成\\\hline
S&&&预先获得&&服务请求2\\\hline
\end{tabular}
\end{table}