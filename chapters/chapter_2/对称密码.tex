% !TEX root = ../../现代密码学简介.tex
\chapter{对称密码}
\section{什么是对称密码}
通过上一章我们知道，一个密码体制由明文空间、密文空间、密钥空间、加密算法、解密算法构成。如果两个人要进行加密通信，那么发送者利用密钥，使用加密算法加密明文，生成密文，将密文传递给接收者。接收者利用密钥，使用解密算法解密密文，生成明文。这就是加密通信的基本过程。那么所谓的对称密码，就是在一次加密通信的过程中，发送者和接收者使用的密钥是同一个密钥。
\section{对称密码要研究什么}
从我们上面叙述的过程来看，对称密码主要需要研究两个部分：用什么方式加密、解密，以及如何让加密和解密者共享同一个密钥。\par
所谓用什么方式加密、解密，主流方法为使用流密码或分组密码。而密钥共享的方式，则有许多种。本章主要的内容就是阐述这两个方面。
\section{对称密码的加密、解密方式}
从上一章我们可以知道，最安全的密码，是一次一密。即：\par
对于$n$位二进制串明文$m_1m_2\cdots m_n$, 密钥为$n$位二进制串$k_1k_2\cdots k_n$，其每一位都是$0$或$1$的随机数。密文为$n$位二进制串$c_1c_2\cdots c_n$, 加密方式为明文与密钥的逐比特异或，解密方式为密文与密钥的逐比特异或。\par
同时我们知道，一次一密虽然是完全安全的，但其缺陷也很明显。首先，既然密钥的长度和明文一样长，并且在加密通信前双方都要知道密钥，那不如双方直接共享明文；其次，同一个随机生成的密钥只能使用于一次加密通信，否则安全性就会降低。\par
为了解决这一问题，在对称密码体制中采用了两种方法：流密码与分组密码。\par
所谓流密码，就是采用一个较短的密钥，以这个较短的密钥生成一个和明文一样长的，近似随机的密钥流，然后再像一次一密那样加密。因此，如果密钥流的随机性接近于一次一密中密钥的真随机性，那么其安全性就会极高。但是，流密码中的密钥流不可能是真随机的，因为加解密双方共享的是那个较短的密钥，而为了加解密的成功性，由这个较短的密钥生成的密钥流也应是相同的，因此，这个密钥流实际上是确定的。所以，流密码的安全性，就在于以较短的密钥生成密钥流的算法。\par
所谓分组密码，就是将明文分成若干个相同长度的分组，然后对每个分组进行加密。从本质上来说，分组密码实际上处理的是固定长度明文的问题。大多数的分组密码，都是采用扩散、混淆等传统对称密码中采用的加密手段，让明文与密文、密文与密钥之间的关系尽可能地难以破解。
\section{对称密码的密钥分配方式}
对称密码的密钥分配问题，我们主要研究的是在一个节点充分多的网络中如何建立高效、安全的信道。这个问题是有其实际意义的。试想在一个互联网公司内，有许多员工和服务器。对每个服务器，每个员工都需要利用自己的账号密码登陆。那么，如果有$m$个员工和$n$个服务器，那么最原始的想法，每个员工、服务器之间都拥有一个密钥，那么总共需要$mn$个密钥。那么这能不能够优化呢？我们下面抽象该问题：\par
我们现在考虑有$n$个人，他们需要进行对称密码的加密通信。那么，由于每次对称密码通信都需要一个密钥，所以，最原始的想法是这$n$个人两两之间有一个密钥用于长期的加密通信。那么，这$n$个人两两加密通信就一共需要$\ext\frac{n\pth{n-1}}{2}$个密钥。这种做法常被称作点对点密钥分配。其好处是安全，如果在这个加密通信网络中有一个人泄露了密钥，那么只有与这个人进行的加密通信受到影响，其他人之间的加密通信是不会受到影响的。但是，其缺点为可延展性差。密钥的数量是$O(n^2)$量级的，这导致密钥的数量会随着加密通信网络成员的增多而迅速增多。同时，新成员的加入、旧成员的减少都会影响这整个加密通信网络的成员。\par
为了弥补其缺点，我们想到的最有效的方法是将这些缺点从加密通信的双方身上转移到一个第三方机构——密钥分配中心(Key Distribution Center, KDC). 其具体做法为：\par
每一个加密通信网络中的用户，都与KDC共享一个密钥，称为主密钥。因此，$n$个节点的加密通信网络中共有$n$个主密钥。在一次加密通信的过程中，加密通信双方利用主密钥，向KDC请求一个密钥，称为会话密钥。双方利用会话密钥进行加密通信。加密通信完成后，会话密钥即可销毁。\par
从上述过程中我们可以看到，加密通信网络的密钥数量从$O(n^2)$变为了$O(n)$, 同时新成员的加入、旧成员的减少都不会影响整个加密通信网络中的任何一个成员。
\subsubsection{安全协议记号}
接下来，我们将叙述具体的安全协议。为了方便叙述，我们使用了通用的安全协议记号，即：
\[A\to B: M\]
代表$A$发送给$B$一个消息$M$.
\[A\to B: \brace{X}_{K_{A, B}}\]
代表$A$发送给$B$一个信息，该信息是用密钥$K_{A, B}$加密明文$X$获得的密文。
\subsubsection{NS协议}
基于KDC的密钥分配方式，其核心在于如何利用主密钥获得会话密钥。常用的方法为Needham-Schroeder协议，简称NS协议。其基本步骤为：\par
假设A和B要进行加密通信，$S$为KDC, $K_{AS}, K_{BS}$分别是$A$和$B$拥有的主密钥，$ID_A, ID_B$分别为$A$和$B$的身份识别号，$N_A, N_B$分别为$A$和$B$产生的一个一次性随机数，$K_{AB}$为加密通信所需要的会话密钥。那么，其步骤为：
\begin{enumerate}
	\item $A$发送给$S$一个信息，用于确定他和$B$的身份，告诉$S$他想与$B$进行通信
	\[A\to S: ID_A, ID_B, N_A\]
	\item KDC, 即$S$, 生成一个$K_{AB}$, 并将其用$K_{BS}$与一部分数据加密后返回给$A$
	\[S\to A: \brace{N_A, K_{AB}, ID_B, \brace{K_{AB}, ID_A}_{K_{BS}}}_{K_{AS}}\]
	\item $A$使用$K_{AS}$解密了上一步获得的密文，同时将得到的$\brace{K_{AB}, A}_{K_{BS}}$发送给$B$
	\[A\to B: \brace{K_{AB}, ID_A}_{K_{BS}}\]
	\item $B$发送给$A$一个用$K_{AB}$加密的随机数
	\[B\to A: \brace{N_B}_{K_{AB}}\]
	\item $A$利用$K_{AB}$解密了上一步得到的密文，并将其减一后用$K_{AB}$加密发送给$B$
	\[A\to B: \brace{N_B - 1}_{K_{AB}}\]
\end{enumerate}

我们在分析安全通信协议的时候，需要考虑的是，如何证明本轮收到的信息是对方发的，并且是针对自己上一轮发送信息的回馈。那么，我们从第二轮开始分析：\par
第二轮中，由于$K_{AS}$只有$A$和$S$知道，因此，如果能用$K_{AS}$正确解密信息，就说明获得的信息是$S$发的。同时，如果解密得到了$N_A$，就说明这次收到的信息是$S$针对上次发送的信息的回馈。\par
第五轮中，由于$K_{BS}$只有$B$和$S$知道，因此，只有$B$能获得第三轮中发送的$K_{AB}$. 因此，如果$B$使用$K_{AB}$解密得到的信息确实是第四步生成的随机数减一，那么就说明获得的信息确实是$A$发的，并且也确实是对之前发送信息的回馈。\par
但是，这样的安全通信协议可以被重放攻击。如果一个攻击者使用了一个旧的，已经被泄露出来的$K_{AB}$, 那么他可以重放信息$\brace{K_{AB}, A}_{K_{BS}}$给$B$, 从而让$B$误以为自己是$A$. 这样攻击的主要原因就在于该协议的第三步中，$B$无法确定发送者是否是当前的$A$.\par
在实际应用中，比如说，一个员工可以多次重复上述协议的前几步，收集其与每台服务器之间通信的$\brace{K_{AB}, ID_A}_{K_{BS}}$. 那么即使他被解雇了，他依然可以利用这些信息来登录服务器。这个漏洞在被指出之前，持续了有快十年。