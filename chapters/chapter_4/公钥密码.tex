% !TEX root = ../../现代密码学简介.tex
\chapter{公钥密码}
\section{简介}
之前我们讲到，最安全的密码体系是一次一密。但是，由于其需要用安全信道传输的密钥长度至少于明文一样长，并且一个密钥只能用一次，因此，与其将密钥传输，不如将明文传输。所以，一次一密的缺陷也十分明显。为了解决这一问题，之前我们采取的方法是使用各种手法，包括流密码以及分组密码等，来缩短密钥的长度。而公钥密码则提供了另一种不同的思路：减弱对安全信道的需求。其基本思想为：
\begin{enumerate}
	\item 由解密方生成一对密钥，称为公钥（记作$SK$）和私钥（记作$PK$）。
	\item 解密方将公钥传送给加密方（不需要通过安全信道）。
	\item 加密方利用公钥加密明文，传递给解密方。
	\item 解密方利用私钥解密密文。
\end{enumerate}

因此，和之前讲到的对称密码体系类似，公钥密码体系包含的三个关键算法是：公钥-私钥生成算法，加密算法，解密算法。\par
要在实践中实现这个思想，我们得满足：
\begin{itemize}
	\item 生成公钥、密钥对的算法较容易
	\item 用公钥加密明文的算法较容易
	\item 用密钥解密密文的算法较容易
	\item 由公钥不能（或者很难）得到对应的密钥
	\item 由密文和公钥不能（或者很难）得到对应的明文
	\item 公钥、私钥可交换。即：
	\begin{equation}
	\D{PK}{\E{SK}{m}} = \D{SK}{\E{PK}{m}}
	\end{equation}
\end{itemize}

上述的六个要求，实质上就是需要我们找到如下的一种“单向陷门函数”$f(x)$:\par
对于从$X$到$Y$的函数$f(x)$, 如果$\forall x\in X$, $f(x)$的计算较容易，而对于几乎所有$Y$中的元素$y$, 找出其对应的$x$都是计算不可行的。但是，如果掌握一个“陷门”$z$, 则求逆较容易。则称$f(x)$为一个单向陷门函数。\par
比如说将一个怀表拆成许多零件是容易的，将零件重新装回一个怀表是几乎不可能的。但如果我们拥有怀表的构造说明书，那么用零件装回怀表又是较容易的。这就是现实中的一个单项陷门函数。\par
如果我们找到了这样一种单向陷门函数，那么我们可以用它来构造公钥。\par
但是，这个定义中，“较容易”、“几乎所有”、“计算不可行”都是一种直观上的感性词语。其真正的严格数学定义需要用到概率多项式时间等高深的方法，这里不再介绍。\par
此外，公钥密码体系还有一个重要的特点是，其安全性基于数论知识，而非类似于分组密码的代换与替换。并且，在之后的算法细节中我们会了解到，公钥密码体系的算法比对称密码体系的算法要慢许多。同时，由于并非一次一密，因此其安全性从本质上说并不比对称密码体系高。\par
公钥密码体系也称为非对称密码体系，因为用于加密的公钥不能解密其密文。\par
同时，公钥密码除了解决了密钥分配问题，即对安全信道的需求问题，其还解决了另外一个问题：数字签名问题。即，在以往的对称加密体系中，我们无法得知收到的密文是否来自于我们选择的加密方。
\section{RSA密码}
在现在的互联网安全中，RSA密码体系承担了大部分的工作。如Outlook等加密邮件都是使用RSA的密码体系。
\subsection{基本框架}
之前讲到，公钥密码体系包括公钥-私钥生成算法，加密算法和解密算法。下面介绍其基本框架。值得指出的是，这里只是写了其操作步骤，而没有说明其具体实现方法。具体的实现方法会在后面再介绍。
\subsubsection{公钥-私钥生成算法}
\begin{enumerate}
\item 取两个素数$p, q$, 且$p\neq q$
\item 计算$n=pq$和$\phi(n)=\pth{p-1}\pth{q-1}$
\item 取$e$, 使得$1<e<\phi(n)$且$\pth{\phi\pth{n}, e}=1$, 即$\phi(n)$与$e$互素
\item 计算$d$, 使得$d$满足
\begin{equation}
de\equiv 1\pmod{\phi(n)}
\end{equation}
\item 公钥为$\pth{e, n}$, 私钥为$\pth{d, n}$.
\end{enumerate}
\subsubsection{加密算法}
对于公钥$\pth{e, n}$, 加密者需要加密的二进制字符串对应的二进制数为$m$. 要求$m<n$. 加密操作为
\begin{equation}
c\equiv m^e\pmod{n}
\end{equation}

再将每个$c$拼起来形成密文串。
\subsubsection{解密算法}
对于私钥$\pth{d, n}$, 解密者将接收到的密文$c$作解密操作
\begin{equation}
m\equiv c^d\pmod{n}
\end{equation}
\subsection{算法细节}
上一小节讨论了RSA的整体算法结构。接下来，分几个部分介绍一下具体的算法细节。
\subsubsection{大整数}
在RSA中，需要使用到许多大整数。这些大整数规模在1024比特左右。因此，我们在程序实现时，采用一个大整数类\verb`BigInteger`, 其将大整数以二进制串的形式存储，成员变量为符号位\verb`sign`(布尔值，非负为\verb`true`)，二进制串长度\verb`length`, 以及由低位向高位存储的二进制串\verb`value`.
\subsubsection{大整数相乘模运算}
最常用的运算是求两个大整数的乘积对于另一个大整数的模。为了使中间结果的位数不太大，我们可以考虑如下结论：\par
若$\ext a=\sum_{i=0}^na_i2^i$, 那么
\begin{equation}
ab\bmod{c}=\sum_{i=0}^n\pth{a_ib2^i\bmod{c}}
\end{equation}

比如说，如果$\ext a=\pth{1001}_2=2^3+2^0$, 那么
\[
ab\bmod{c}=\pth{2^3b\bmod{c}}+\pth{2^0b\bmod{c}}
\]

利用这种想法，其C程序实现如下：
\begin{prove}
\begin{verbatim}
BigInteger mulmod(const BigInteger mul1,
                  const BigInteger mul2, const BigInteger mod)
{
    if (mul1 == 0 || mul2 == 0)
        return 0;
    
    BigInteger product = 0;
    BigInteger modMul1 = mul1;
    for (int digit = 0; digit < mul2.length; digit++)
    {
        modMul1 = (modMul1 << 1) % mod;
        if (mul2.value[digit])
            product = (product + modMul1) % mod;
    }
    
    return product;
}
\end{verbatim}
\end{prove}
\subsubsection{大整数幂模运算}
此外，还有一个常用的运算是对于大整数$a, b, c$, 求$a^b\bmod{c}$. 这里常用的方法为快速指数法。其基本思想为：\par
假设$b$的二进制表示为$b_kb_{k-1}\cdots b_0$, 即
\begin{equation}
b=b_k2^k+b_{k-1}2^{k-1}+\cdots +2b_1+b_0
\end{equation}

那么
\begin{equation}
a^b=\pth{\cdots \pth{\pth{a^{b_k}}^2a^{b_{k-1}}}^2\cdots a^{b_{1}}}^2a^{b_0}
\end{equation}

比如说，如果$b=9$, 那么我们可以
\[a^b\bmod{c}=a^{8+1}\bmod{c}=\pth{\pth{a^2}^2}^2\cdot a\bmod{c}\]

将原本需要算9次的乘法改进成算4次。此外，我们还可以每一次乘法都求模，这样可以使中间结果更小，如：\par
$\ext b=\pth{1001}_2=2^3+2^0$, 那么
\[
a^b\bmod{c}=\pth{\pth{\pth{a^2\bmod{c}}^2\bmod{c}}^2\bmod{c}}\cdot a
\]

其C程序实现为：
\begin{prove}
\begin{verbatim}
BigInteger fastExp(const BigInteger base,
                   const BigInteger exponent,
                   const BigInteger mod)
{
    BigInteger power = 1;
    
    for (int digit = exponent.length - 1; digit >= 0; digit--)
    {
        power = mulmod(power, power, mod);
        if (exponent.value[digit])
            power = mulmod(power, base, mod);
    }
    
    return power;
}
\end{verbatim}
\end{prove}
\subsubsection{互素判定}
判断两个数是否互素，我们常用欧几里德辗转相除法求两个数的最大公因数。其基本原理为
\begin{theorem}
对于整数$a, b$
\begin{equation}
\pth{a, b}=\pth{b, a\bmod{b}}
\end{equation}
\end{theorem}

其C程序实现如下：
\begin{prove}
\begin{verbatim}
BigInteger gcd(BigInteger a, BigInteger b)
{
    if (a % b == 0)
        return b;
    return gcd(b, a % b);
}
\end{verbatim}
\end{prove}
\subsubsection{求乘法逆元}
由裴蜀定理可知，对于整数$x, y$, 存在整数$a, b$, 使得
\begin{equation}
ax+by=\pth{x, y}
\end{equation}

那么，如果$\pth{x,y} = 1$, 那么存在整数$a, b$, 使得
\begin{equation}
ax+by=1
\end{equation}
因此
\[ax=-by+1\]

故
\begin{equation}
ax\equiv 1\pmod{y}
\end{equation}

因此，我们如果可以由$x, y$找出对应的$a, b$, 那么$a$就是$x$模$y$的乘法逆元。\par
因此，我们使用扩展欧几里德算法。其C程序实现如下：
\begin{prove}
\begin{verbatim}
BigInteger extendGcd(BigInteger x, BigInteger y,
                     BigInteger &a, BigInteger &b)
{
    if (y == 0)
    {
        a = 1;
        b = 0;
        return x;
    }
    
    BigInteger r = extendGcd(y, x % y, a, b);
    BigInteger tmp = a;
    a = b;
    b = tmp - x / y * b;
    return r;
}
\end{verbatim}
\end{prove}

从而，求乘法逆元的C程序实现如下：
\begin{prove}
\begin{verbatim}
BigInteger inverse(const BigInteger a, const BigInteger mod)
{
    BigInteger inverse = 0;
    BigInteger tmp = 0;
    extendGcd(a, mod, inverse, tmp);
    return inverse;
}
\end{verbatim}
\end{prove}
\subsubsection{素数$p, q$的选取}
在之后会介绍，RSA的安全性取决于$p, q$要是大素数。那么，我们就需要判断素数。最初等的方法是从$3$到$\sqrt{n}$挨个判断是否是$n$的因子。但是对于极大的数，这样判断方法是不现实的。因此，下面介绍一下常用的判断素数的方法：Miller-Rabin素数测试。\par
Miller-Rabin素数测试基于一个基本定理：
\begin{theorem}
对于奇数$n=2^sd+1$, 其中$d$为奇数。若存在$a$满足$\forall 0\leq r\leq s-1$, 有
\begin{gather}
a^d\not\equiv 1\pmod{n}\\
a^{2^rd}\not\equiv 1\pmod{n}
\end{gather}

则$p$不是素数。
\end{theorem}

由此定理，我们取充分多的$a$, 对于每个$a$我们测试所有的$0\leq r\leq s-1$, 只要有一个不满足，那么$p$就不是素数。如果我们取的$a$充分多，并且都没有找到不满足定理的值，那么$p$就可以被看作一个素数。\par
那么，我们取多少个$a$比较合适呢？事实上，如果奇数$n$是$k$位二进制数，并对它进行$t$次Miller-Rabin测试均返回成功，那么其为合数的概率满足
\begin{equation}
P<\begin{dcases}k^24^{2-\sqrt{k}}&k\geq 2\\k^{\frac{3}{2}}2^tt^{-\frac{1}{2}}4^{2-\sqrt{tk}}&y=2, k\geq 88\text{或}3\leq t\leq \frac{k}{9}, k\geq 21\\\frac{7}{20}k2^{-5t}+\frac{1}{7}k^{-\frac{k}{2}-2t}+12k2^{-\frac{k}{4}-3t}&t\geq\frac{k}{9}, k\geq 21\\\frac{1}{7}k^{\frac{15}{4}}2^{-\frac{k}{2}-2t}&t\geq \frac{k}{4}, k\geq 21\end{dcases}
\end{equation}

对于$1024$比特的$n$, 选取$40$个$a$以后$n$为合数的概率要小于$2^{-83}$. 而事实上，我们也常对$n$使用40次Miller-Rabin测试。
其C程序实现如下：
\begin{prove}
\begin{verbatim}
bool Miller_Rabin(BigInteger n, int round)
{
    BigInteger m = n - 1;
    int k = 0;
    while (!m.getValue()[0])
    {
        k++;
        m = m >> 1;
    }
    
    for (int i = 0; i < round; i++)
    {
        BigInteger a = BigInteger::getRand() % (n - 1) + 1;
        BigInteger b = BigInteger::fastExp(a, m, n);
        if (b == 1)
            return true;
        
        for (int j = 0; j < k; j++)
        {
            if (b == n - 1)
                return true;
            b = BigInteger::mulmod(b, b, n);
        }
    }
    return false;
}
\end{verbatim}
\end{prove}

上述讲的是如何测试$p, q$是否为素数。那么如何生成$p, q$呢？常用的方法是：\par
随机生成一个1024比特的奇数，然后对其进行40轮Miller-Rabin测试。如果不是素数，则将其自增2.\par
看似这个方法很没有效率，但是，根据素数定理，在$0$到$N$之间，每两个相邻的素数之间的平均距离为$\ln N$. 因此，对于1024比特的奇数$n$, 如果其不为素数，那么其前后两个素数之间的距离约为$\ln n$. 故其平均需要再往后测试
\[\frac{\ln n}{2}\approx 354\]

次即可。\par
综上，公钥-私钥对的产生的C程序算法如下：
\begin{prove}
\begin{verbatim}
void generateKeys(BigInteger &pub, BigInteger &pri)
{
    pub = getRandBit(1024);
    if (!pub.getValue()[0])
        pub += 1;
    
    while (!Miller_Rabin(pub, 40))
        pub += 2;
    
    
    pri = getRandBit(1024);
    if (!pri.getValue()[0])
        pri += 1;
    
    while (!Miller_Rabin(pri, 40))
        pri += 2;
}
\end{verbatim}
\end{prove}
\subsubsection{$e$的选取}
由于RSA算法的安全性主要在于$p, q$的选取，因此，作为公钥的$e$的选取就没有必要是随机的。常用的$e$取自$3,5,17,257,65537$. 判断$e$与$\phi(n)=\pth{p-1}\pth{q-1}$是否互素可以用欧几里德辗转相除法\verb`gcd()`来求其最大公因数，判断其是否为$1$.\par
其C程序实现如下：
\begin{prove}
\begin{verbatim}
BigInteger generateE(BigInteger phi)
{
    BigInteger list[5] = {65537, 257, 17, 5, 3};
    for (int i = 0; i < 5; i++)
        if (BigInteger::gcd(phi, list[i]) == 1)
            return list[i];
    
    return -1;
}
\end{verbatim}
\end{prove}
\subsubsection{$d$的求值}
由定义，$d$是$e$模$\phi(n)$的乘法逆元。因此，我们采用扩展欧几里德算法求$d$.
\subsubsection{加密}
RSA的加密过程实际上就是求大整数的幂的模。因此，我们可以采用快速指数法。
\subsubsection{解密}
RSA的解密过程是解密方进行的操作。而解密方拥有的数有$p, q, n, \phi(n), e, d$以及密文$c$.\par
解密方可计算
\begin{equation}
\begin{dcases}d_p=d\bmod{\pth{p-1}}\\d_q=d\bmod{q-1}\end{dcases}, \begin{dcases}m_p=c^{d_p}\bmod{p}\\m_q=c^{d_q}\bmod{q}\end{dcases}
\end{equation}

于是由费马小定理可化简得到
\[\begin{dcases}m_p\equiv m\pmod{p}\\m_q\equiv m\pmod{q}\end{dcases}\]

运用中国剩余定理:
\begin{equation}
m\equiv qe_pm_p+pe_qm_q\pmod{pq}
\end{equation}

其中$qe_p\equiv 1\pmod{p}, pe_q\equiv 1\pmod{q}$.\par
如果我们采用快速指数法计算$m_p, m_q$, 采用扩展欧几里德算法计算$e_p, e_q$, 即可得到$m$.\par
其C程序实现如下：
\begin{prove}
\begin{verbatim}
BigInteger RSA_DEC(BigInteger cipher, BigInteger d,
                   BigInteger p, BigInteger q)
{
    BigInteger dp = d % (p - 1);
    BigInteger dq = d % (q - 1);
    
    BigInteger mp = fastExp(cipher, dp, p);
    BigInteger mq = fastExp(cipher, dq, q);
    
    BigInteger ep = inverse(q, p);
    BigInteger eq = inverse(p, q);
    
    BigInteger n = p * q;
    
    BigInteger tmp1 = mulmod(q, ep, n);
    tmp1 = mulmod(tmp1, mp, n);
    
    BigInteger tmp2 = mulmod(p, eq, n);
    tmp2 = mulmod(tmp2, mq, n);
    
    return tmp1 + tmp2;
}
\end{verbatim}
\end{prove}