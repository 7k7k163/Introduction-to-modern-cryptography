% !TEX root = ../../现代密码学简介.tex
\chapter{消息认证}
\section{简介}
我们在进行安全通信的过程中，有许多需要关注的问题。本章介绍的技巧主要与两个问题有关：
\begin{itemize}
	\item 接收者如何确认发送者的身份
	\item 接收者如何确认消息没有被篡改
\end{itemize}

这两个问题在密码学中被称作消息认证(Message Authentication)问题。\par
在上一章讨论的安全协议中，我们可以利用一些复杂的安全协议，达到甚至在没有第三方的情况下，仍然能确认发送者的身份。但是，我们到目前为止却并没有找到能保证消息没有被篡改的方法。\par
因此，我们首先解决第二个问题：如何确认消息没有被篡改。
\section{哈希函数}
\subsection{定义}
在讨论哈希函数之前，我们需要充分讨论一下目前需要完成的目标：接收者如何确认消息没有被篡改。如果一个算法要实现这个目标，那么这个算法必然是接收我们要传递的消息$m$，并产生一个输出$h$。发送者利用这个算法，将消息$m$以及输出$h$都发送给接收者，而接收者再次利用这个算法处理收到的消息$m'$，通过对比输出$h'$与发送者发送的输出$h$，判断消息$m$是否得到篡改。那么，这一算法最重要的一点是什么呢？显然是尽量避免两个不同的消息$m_1\neq m_2$, 其通过这个算法产生的输出$h_1$和$h_2$相同。如果产生这种情况，我们则称该算法拥有一个\textbf{碰撞}。更进一步地，从抵抗攻击的角度来看，这种算法应该使敌手在截获消息经过该算法的输出$h$以后，不能或者难以生成一个篡改的消息$m'$, 使得其经过该算法的输出$h'=h$. 在最理想的状态下，实现这一目标最好的方法就是，从$h$中敌手无法获得任何有关$m$的信息。\par
根据以上的讨论，这个算法$H(x)$需要满足的性质有：
\begin{itemize}
	\item 可以适用于任意长度的消息$x$
	\item 算法的输出$H(x)$是固定长的
	\item 由输入$x$求得输出$H(x)$的过程较容易，可用硬件和软件实现
	\item 由输出$H(x)$反求得输入$x$的过程是不可行的，或者是难以计算的
	\item 给定$x$, 难以求得$y$, 使得$H(x)=H(y)$. 这一点被称作\textbf{弱碰撞抵抗}
	\item 难以求得任何一对$\pth{x, y}$, 使得$H(x)=H(y)$. 这一点被称作\textbf{强碰撞抵抗}
\end{itemize}

对于第二点，即算法的输出是固定长的。这是由于上述讨论中我们提到，从输出中敌手无法获得输入的任何信息，这里甚至包括输入的消息的长度。不仅如此，在实际操作中，由于“由输入求得输出的过程较容易”这一要求，如果输出是固定长的，那么程序中内存分配等问题就相对较容易。因此，现在通行的算法的输出都是固定长度的。同时，我们也应该了解到，这个“固定长”的长度一般是小于消息的长度的。\par
用于确认消息没有篡改的算法被称为哈希函数(Hash fucntion). 又称为散列函数。其接受一个消息作为输入，产生的输出被称为该消息的摘要(digest).\par
一个优秀的哈希函数，应该能做到，对于输入消息的任何一点修改，都会导致输出的巨大改变。下面展示一个例子：\par
如图是东南大学的校徽，我们对其左上角第一个像素进行篡改。
\begin{figure}[H]
\centering
\begin{minipage}[t]{0.49\textwidth}
\centering
\includegraphics[width=10em]{chapters/chapter_6/MD5_unchanged.jpg}
\caption{未篡改的原消息}
\end{minipage}
\begin{minipage}[t]{0.49\textwidth}
\centering
\includegraphics[width=10em]{chapters/chapter_6/MD5_changed.jpg}
\caption{篡改后的消息}
\end{minipage}
\end{figure}

我们利用MD5哈希算法求其摘要：
\begin{itemize}
	\item 未篡改的原消息\par
	\verb`d3f83ad3cee8eb1c407955509b9f08a0`
	\item 篡改后的消息\par
	\verb`d5a15358b5c875e89600b0b53510f5c7`
\end{itemize}

由此可见，即使对原消息进行一丝一毫的修改，都会产生摘要值的巨大改变。\par
除了上述功能之外，由于其输出的长度是固定的，因此，哈希函数还有一个重要的用途：当我们要处理的数据很大时，将其通过哈希函数，压缩成较小的数据，则更好处理。
\subsection{Merkle-Damg\aa rd结构}
在密码学中，许多哈希函数都基于一个类似的结构——Merkle-Damg\aa rd结构。首先，我们先介绍一下该结构的两个主要部分。
\subsubsection{服从MD结构的填充函数}
对于正整数$b$来说，如果将所有长度为$b$的整数倍的二进制串构成的集合记作$B$, 将所有长度小于$2^b$的二进制串构成的集合记作$U$. 同时，对于长度为$b$的整数倍的二进制串$M$，将其从头开始分割为长度均为$b$的二进制子串，那么称每个子串为$M$的一个块。\par
那么对于非空集合$D\subset U$, 以及函数$\mathrm{Pad}:D\to B$, 称满足以下条件的函数$\mathrm{Pad}$为一个相对于$b$的服从MD结构的填充函数：
\begin{itemize}
	\item 对于任意$M\in D$, $M$是二进制串$\mathrm{Pad}\pth{M}$的前缀
	\item 对于任意$M_1, M_2\in D$, 如果$M_1$和$M_2$的长度相同，那么$\mathrm{Pad}\pth{M_1}$和$\mathrm{Pad}\pth{M_2}$的长度相同
	\item 对于任意$M_1, M_2\in D$, 如果$M_1$和$M_2$的长度不同, 那么$\mathrm{Pad}\pth{M_1}$和$\mathrm{Pad}\pth{M_2}$的最后一个块不同
\end{itemize}

对于任意正整数$b$, 我们可以轻易地构造出服从MD结构的填充函数：对于长度为$k$的二进制串$M$, 如果$k\bmod b\neq b-1$, 那么将二进制串$k$后不停地填充$0$, 直到新串的长度模$b$为$b-1$. 然后，将最初串$M$的长度$k$的二进制表示的最后一位填充在最后，形成一个长度为$b$的整数倍的串。可以轻松地证明，这种填充方法，是服从MD结构的。\par
在上述构造方法中，我们提到，在新串的末尾填充最初串的长度，这一方法被称为Merkle-Damg\aa rd强化。
\subsubsection{单向压缩函数}
所谓单向压缩函数，其类似于输入是固定长度的哈希函数。对于单向压缩函数$h$, 其接受两个参数，一个为长度为$b$的二进制串，一个为长度为$v$的二进制串，并输出一个长度为$b$的二进制串。这可以看成一个输入长度为$b+v$, 输出长度为$b$的哈希函数。类似于哈希函数，单向压缩函数也有碰撞抵抗等要求。
\subsubsection{算法}
要实现服从Merkle-Damg\aa rd结构的输出为$b$比特的哈希函数$H$，需要两个正整数$b, v$. 一个相对于$v$的使用了Merkle-Damg\aa rd强化的服从MD结构的填充函数$\mathrm{Pad}$, 一个接受参数为分别为长度为$b$和$v$的二进制串的单向压缩函数$h$, 以及一个长度为$b$的初始值$\mathrm{IV}$.\par
那么，Merkle-Damg\aa rd结构的算法为：
\begin{enumerate}
	\item 将输入的二进制串$M$用$\mathrm{Pad}$函数填充为长度为$nb$比特的二进制串$M'=\mathrm{Pad}\pth{M}$
	\item 将$M'$从头开始分割为$n$个长度为$b$比特的子串$M_1, M_2, \ldots, M_n$
	\item 对于每个子串$M_i$, 计算$H_i=h\pth{M_i, H_{i-1}}$, 其中$H_0=\mathrm{IV}$
	\item $H$的输出即为$M_n$
\end{enumerate}

同时，Merkle和Damg\aa rd分别独立证明出来，如果单向压缩函数$h$能抵抗碰撞，那么$H$也能抵抗碰撞。\par
接下来，介绍两个基于Merkle-Damg\aa rd结构的哈希算法：MD5和SHA-1
\subsection{MD5}
MD5哈希算法的输出为128比特的二进制串，其$b=128, v=512$. 然而，MD5算法并不安全。在2012年，MD5算法被卡耐基梅隆大学软件工程研究所宣布能被密码学方法破解，不适合将来的使用。但是，如果只是简单的摘要对比，对安全性并不高的话，MD5哈希算法也是一个比较简便的方法。\par
在MD5算法中，二进制串既要以比特串的形式进行异或等逻辑运算，也要以二进制数的形式进行加减等算术运算。因此，在MD5算法中涉及到了数据的存储问题。由于是在计算机上实现的，而计算机中一个数据单元是1字节，也就是8比特。因此，数据存储的问题变成了字节存储顺序的问题。比如说，以十六进制表示的二进制串$1234$究竟表示的是$1\times 16^3+2\times 16^2+3\times 16+4$还是$4\times 16^3+3\times 16^2+2\times 16+1$呢？前者被称为小端法，后者被称为大端法（但无论是小端法还是大端法，每个字节内部比特的存储顺序都是小端法）。而MD5算法中使用的是大端法。但是，现代计算机以及本算法使用的\verb`BigInteger`类均采用小端法处理二进制串。因此，在C++程序实现的时候，每次讲二进制串转化为数字，以及数字转化为二进制串时，都要调整端序。\par
虽然事实上，端序并不会影响加密性，但是，作为一个通行的标准，MD5码仍然需要我们使用大端法。\par
MD5算法包括了四个步骤：
\begin{enumerate}
	\item 填充比特
	\item 填充长度
	\item 初始化链接变量
	\item 处理消息
\end{enumerate}

其中，填充比特和填充长度就是之前讲的Merkle-Damg\aa rd结构中的填充函数，而初始化链接变量是为了之后处理消息使用的参数，处理消息则是运用单向压缩函数，并进行输出。
\subsubsection{填充比特}
假设输入消息的长度为$k$, 那么如果$k\bmod{512}<448$, 那么将其后先填充一个`1', 再不停填充`0'直到新串的长度模$512$等于$448$. 如果$k\bmod{512}>448$, 那么先将其后填充一个`1', 然后再不停填充0，填满一个块以后，再继续填充$448$位。\par
其C程序实现如下：
\begin{prove}
\begin{verbatim}
BigInteger appendPaddingBits(BigInteger plainText)
{
    int spareLength = plainText.getLength() % 512;
    if (spareLength < 448)
    {
        int appendLength = 448 - spareLength;
        bool *appendValue = new bool[appendLength];
        *(appendValue + appendLength - 1) = true;
        int index = appendLength - 2;
        while (index > -1)
        {
            *(appendValue + index) = false;
            index--;
        }
        plainText.append(appendValue, appendLength);
    }
    else if (spareLength > 448)
    {
        int appendLength = 512 - spareLength + 448;
        bool *appendValue = new bool[appendLength];
        *(appendValue + appendLength - 1) = true;
        int index = appendLength - 2;
        while (index > -1)
        {
            *(appendValue + index) = false;
            index--;
        }
        plainText.append(appendValue, appendLength);
    }
    return plainText;
}
\end{verbatim}
\end{prove}
\subsubsection{填充长度}
记最初消息的长度为$k$. 将其表示成二进制串，如果其长度小于64位，则再其首部填0；如果其长度大于64位，则截取其最后64位。\par
这里由于涉及到数向二进制串的转化，需要调整端序。\par
其C程序实现如下：
\begin{prove}
\begin{verbatim}
BigInteger appendLength(BigInteger appendedText, int textLength)
{
    BigInteger appendBigInt(textLength);
    appendBigInt.limitTo(64);
    BigInteger bitSlice[8];
    for (int byte = 0; byte < 8; byte++)
    {
        bitSlice[byte] = appendBigInt.slice(8 * byte, 
                                            8 * (byte + 1));
        appendedText.append(bitSlice[7 - byte]);
    }
    return appendedText;
}
\end{verbatim}
\end{prove}
\subsubsection{初始化链接变量}
在MD5最初使用的大端法表示下，MD5使用的4个32位链接变量的值分别是：
\begin{itemize}
	\item \verb`A=0x01234567`
	\item \verb`B=0x89abcdef`
	\item \verb`C=0xfedcba98`
	\item \verb`D=0x76543210`
\end{itemize}

但是，由于这也涉及到数向二进制串的转化，因此，需要调整端序。\par
其C程序实现如下：
\begin{prove}
\begin{verbatim}
BigInteger A, B, C, D;
void initializeMDBuffer()
{
    A = BigInteger("0x67452301");
    B = BigInteger("0xefcdab89");
    C = BigInteger("0x98badcfe");
    D = BigInteger("0x10325476");
}
\end{verbatim}
\end{prove}
\subsubsection{处理消息}
在处理消息的过程中，需要使用四个辅助函数\verb`FF`, \verb`GG`, \verb`HH`, \verb`II`. 而这四个辅助函数又是由另外四个辅助函数\verb`F`, \verb`G`, \verb`H`, \verb`I`定义的。因此，我们首先定义八个函数：
\begin{prove}
\begin{verbatim}
BigInteger F(BigInteger X, BigInteger Y, BigInteger Z)
{
    return (X & Y) | (~X & Z);
}

BigInteger G(BigInteger X, BigInteger Y, BigInteger Z)
{
    return (X & Z) | (Y & ~Z);
}

BigInteger H(BigInteger X, BigInteger Y, BigInteger Z)
{
    return (X ^ Y) ^ Z;
}

BigInteger I(BigInteger X, BigInteger Y, BigInteger Z)
{
    return Y ^ (X | ~Z);
}

BigInteger X[16];
BigInteger T[64];

void FF(BigInteger &A, BigInteger B, BigInteger C, BigInteger D, 
        int k, int s, int i){
    BigInteger tmp = A + F(B, C, D) + X[k] + T[i];
    tmp.limitTo(32);
    A = B + tmp.rotLeft(s);
    A.limitTo(32);
}

void GG(BigInteger &A, BigInteger B, BigInteger C, BigInteger D, 
        int k, int s, int i)
{
    BigInteger tmp = A + G(B, C, D) + X[k] + T[i];
    tmp.limitTo(32);
    A = B + tmp.rotLeft(s);
    A.limitTo(32);
}

void HH(BigInteger &A, BigInteger B, BigInteger C, BigInteger D, 
        int k, int s, int i)
{
    BigInteger tmp = A + H(B, C, D) + X[k] + T[i];
    tmp.limitTo(32);
    A = B + tmp.rotLeft(s);
    A.limitTo(32);
}

void II(BigInteger &A, BigInteger B, BigInteger C, BigInteger D, 
        int k, int s, int i)
{
    BigInteger tmp = A + I(B, C, D) + X[k] + T[i];
    tmp.limitTo(32);
    A = B + tmp.rotLeft(s);
    A.limitTo(32);
}
\end{verbatim}
\end{prove}

在上述程序中，\verb`X[16]`是在下一环节中赋值的变量，每个元素为32比特长的二进制数。\verb`T[64]`是一个辅助数组，\verb`T[i]`的值是$4294967296\abs{\sin\pth{i+1}}$, 这一值也会在下一环节初始化。\par
下一环节则是正式处理消息。首先，根据Merkle-Damg\aa rd结构，需要将处理好的消息分为128比特的块，然后对每个块进行处理。处理的过程中，由于用到了算术运算，因此，也要调整端序。处理的过程就是一个单向压缩函数，其算法就是反复调用之前的\verb`FF`, \verb`GG`, \verb`HH`, \verb`II`四个函数。\par
最后，输出的时候，就是先调整端序，然后拼接并输出。\par
其C程序实现如下：
\begin{prove}
\begin{verbatim}
BigInteger processMessage(BigInteger message)
{
    for (int i = 0; i < 64; i++)
    {
        T[i] = BigInteger((unsigned int)(4294967296 * 
                                            fabs(sin(i + 1))));
        T[i].limitTo(32);
    }
    int N = message.getLength() / 32;
    for (int i = 0; i < N / 16; i++)
    {
        for (int j = 0; j < 16; j++)
        {
            X[j] = message.slice(32 * (i * 16 + j), 
                                    32 * (i * 16 + j + 1));
            BigInteger bitSlice[4] = {X[j].slice(0, 8), 
                                        X[j].slice(8, 16), 
                                        X[j].slice(16, 24), 
                                        X[j].slice(24, 32)};
            X[j] = bitSlice[3];
            X[j].append(bitSlice[2]);
            X[j].append(bitSlice[1]);
            X[j].append(bitSlice[0]);
        }
        
        BigInteger AA = A, BB = B, CC = C, DD = D;
        FF(A, B, C, D, 0, 7, 0);
        FF(D, A, B, C, 1, 12, 1);
        FF(C, D, A, B, 2, 17, 2);
        FF(B, C, D, A, 3, 22, 3);
        FF(A, B, C, D, 4, 7, 4);
        FF(D, A, B, C, 5, 12, 5);
        FF(C, D, A, B, 6, 17, 6);
        FF(B, C, D, A, 7, 22, 7);
        FF(A, B, C, D, 8, 7, 8);
        FF(D, A, B, C, 9, 12, 9);
        FF(C, D, A, B, 10, 17, 10);
        FF(B, C, D, A, 11, 22, 11);
        FF(A, B, C, D, 12, 7, 12);
        FF(D, A, B, C, 13, 12, 13);
        FF(C, D, A, B, 14, 17, 14);
        FF(B, C, D, A, 15, 22, 15);
        
        GG(A, B, C, D, 1, 5, 16);
        GG(D, A, B, C, 6, 9, 17);
        GG(C, D, A, B, 11, 14, 18);
        GG(B, C, D, A, 0, 20, 19);
        GG(A, B, C, D, 5, 5, 20);
        GG(D, A, B, C, 10, 9 ,21);
        GG(C, D, A, B, 15, 14, 22);
        GG(B, C, D, A, 4, 20, 23);
        GG(A, B, C, D, 9, 5, 24);
        GG(D, A, B, C, 14, 9 ,25);
        GG(C, D, A, B, 3, 14, 26);
        GG(B, C, D, A, 8, 20, 27);
        GG(A, B, C, D, 13, 5, 28);
        GG(D, A, B, C, 2, 9 ,29);
        GG(C, D, A, B, 7, 14, 30);
        GG(B, C, D, A, 12, 20, 31);
        
        HH(A, B, C, D, 5, 4, 32);
        HH(D, A, B, C, 8, 11, 33);
        HH(C, D, A, B, 11, 16,34);
        HH(B, C, D, A, 14, 23, 35);
        HH(A, B, C, D, 1, 4, 36);
        HH(D, A, B, C, 4, 11, 37);
        HH(C, D, A, B, 7, 16, 38);
        HH(B, C, D, A, 10, 23, 39);
        HH(A, B, C, D, 13, 4, 40);
        HH(D, A, B, C, 0, 11, 41);
        HH(C, D, A, B, 3, 16, 42);
        HH(B, C, D, A, 6, 23, 43);
        HH(A, B, C, D, 9, 4, 44);
        HH(D, A, B, C, 12, 11, 45);
        HH(C, D, A, B, 15, 16, 46);
        HH(B, C, D, A, 2, 23, 47);
        
        II(A, B, C, D, 0, 6, 48);
        II(D, A, B, C, 7, 10, 49);
        II(C, D, A, B, 14, 15, 50);
        II(B, C, D, A, 5, 21, 51);
        II(A, B, C, D, 12, 6, 52);
        II(D, A, B, C, 3, 10, 53);
        II(C, D, A, B, 10, 15, 54);
        II(B, C, D, A, 1, 21, 55);
        II(A, B, C, D, 8, 6, 56);
        II(D, A, B, C, 15, 10, 57);
        II(C, D, A, B, 6, 15, 58);
        II(B, C, D, A, 13, 21, 59);
        II(A, B, C, D, 4, 6, 60);
        II(D, A, B, C, 11, 10, 61);
        II(C, D, A, B, 2, 15, 62);
        II(B, C, D, A, 9, 21, 63);
        
        A = A + AA;
        A.limitTo(32);
        
        B = B + BB;
        B.limitTo(32);
        
        C = C + CC;
        C.limitTo(32);
        
        D = D + DD;
        D.limitTo(32);
    }
    
    BigInteger output = A.slice(24, 32);
    output.append(A.slice(16, 24));
    output.append(A.slice(8, 16));
    output.append(A.slice(0, 8));
    output.append(B.slice(24, 32));
    output.append(B.slice(16, 24));
    output.append(B.slice(8, 16));
    output.append(B.slice(0, 8));
    output.append(C.slice(24, 32));
    output.append(C.slice(16, 24));
    output.append(C.slice(8, 16));
    output.append(C.slice(0, 8));
    output.append(D.slice(24, 32));
    output.append(D.slice(16, 24));
    output.append(D.slice(8, 16));
    output.append(D.slice(0, 8));
    return output;
}
\end{verbatim}
\end{prove}