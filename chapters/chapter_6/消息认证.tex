% !TEX root = ../../现代密码学简介.tex
\chapter{消息认证}
\section{简介}
我们在进行安全通信的过程中，有许多需要关注的问题。本章介绍的技巧主要与两个问题有关：
\begin{itemize}
	\item 接收者如何确认发送者的身份
	\item 接收者如何确认消息没有被篡改
\end{itemize}

这两个问题在密码学中被称作消息认证(Message Authentication)问题。\par
在上一章讨论的安全协议中，我们可以利用一些复杂的安全协议，达到甚至在没有第三方的情况下，仍然能确认发送者的身份。但是，我们到目前为止却并没有找到能保证消息没有被篡改的方法。\par
因此，我们首先解决第二个问题：如何确认消息没有被篡改。
\section{哈希函数}
\subsection{定义}
在讨论哈希函数之前，我们需要充分讨论一下目前需要完成的目标：接收者如何确认消息没有被篡改。如果一个算法要实现这个目标，那么这个算法必然是接收我们要传递的消息$m$，并产生一个输出$h$。发送者利用这个算法，将消息$m$以及输出$h$都发送给接收者，而接收者再次利用这个算法处理收到的消息$m'$，通过对比输出$h'$与发送者发送的输出$h$，判断消息$m$是否得到篡改。那么，这一算法最重要的一点是什么呢？显然是尽量避免两个不同的消息$m_1\neq m_2$, 其通过这个算法产生的输出$h_1$和$h_2$相同。如果产生这种情况，我们则称该算法拥有一个\textbf{碰撞}。更进一步地，从抵抗攻击的角度来看，这种算法应该使敌手在截获消息经过该算法的输出$h$以后，不能或者难以生成一个篡改的消息$m'$, 使得其经过该算法的输出$h'=h$. 在最理想的状态下，实现这一目标最好的方法就是，从$h$中敌手无法获得任何有关$m$的信息。\par
根据以上的讨论，这个算法$H(x)$需要满足的性质有：
\begin{itemize}
	\item 可以适用于任意长度的消息$x$
	\item 算法的输出$H(x)$是固定长的
	\item 由输入$x$求得输出$H(x)$的过程较容易，可用硬件和软件实现
	\item 由输出$H(x)$反求得输入$x$的过程是不可行的，或者是难以计算的
	\item 给定$x$, 难以求得$y$, 使得$H(x)=H(y)$. 这一点被称作\textbf{弱碰撞抵抗}
	\item 难以求得任何一对$\pth{x, y}$, 使得$H(x)=H(y)$. 这一点被称作\textbf{强碰撞抵抗}
\end{itemize}

对于第二点，即算法的输出是固定长的。这是由于上述讨论中我们提到，从输出中敌手无法获得输入的任何信息，这里甚至包括输入的消息的长度。不仅如此，在实际操作中，由于“由输入求得输出的过程较容易”这一要求，如果输出是固定长的，那么程序中内存分配等问题就相对较容易。因此，现在通行的算法的输出都是固定长度的。同时，我们也应该了解到，这个“固定长”的长度一般是小于消息的长度的。\par
用于确认消息没有篡改的算法被称为哈希函数(Hash fucntion). 又称为散列函数。其接受一个消息作为输入，产生的输出被称为该消息的摘要(digest).\par
除了上述功能之外，由于其输出的长度是固定的，因此，哈希函数还有一个重要的用途：当我们要处理的数据很大时，将其通过哈希函数，输出成较小的数据，则更好处理。
\subsection{Merkle-Damg\aa d结构}
在密码学中，许多哈希函数都基于一个类似的结构——Merkle-Damg\aa d结构。首先，我们先介绍一下该结构的两个主要部分。
\subsubsection{服从MD的填充算法}

\subsubsection{单向压缩函数}